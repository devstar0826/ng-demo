= Angular 2 and Angular CLI Demo

:author: Matt Raible
:email:  matt@raibledesigns.com
:revnumber: 1.0
:revdate:   {docdate}
:subject: Angular CLI
:keywords: Angular CLI, Angular 2, JavaScript, TypeScript, node, npm, Jasmine, Protractor
:doctype: book
:toc: macro
:icons: font
:lang: en
:language: javadocript
:sourcedir: .

This tutorial shows you how to build a simple search and edit application using https://angular.io[Angular 2] and
https://github.com/angular/angular-cli[Angular CLI].

.Source Code
****
If you'd like to get right to it, the https://github.com/mraible/ng2-demo[source is on GitHub]. To run the app,
use `ng serve`. To test it, run `ng test`. To run its integration tests, run `ng serve` in one terminal and
`ng e2e` in another.
****

toc::[]

== What you'll build

You'll build a simple web application with Angular CLI, a new tool for Angular 2 development. You'll create an
application with search and edit features.

== What you'll need

* About 30-45 minutes.
* A favorite text editor or IDE. I recommend https://www.jetbrains.com/idea/[IntelliJ IDEA] and its
https://plugins.jetbrains.com/plugin/8395?pr=idea[Angular 2 TypeScript Live Templates pluginplugin].
* https://github.com/angular/angular-cli[Angular CLI] installed.
* http://nodejs.org/[Node.js] and npm installed. I recommend using https://github.com/creationix/nvm[nvm].

== Create your project

If you don't have Angular CLI installed, install it using `npm install -g angular-cli@latest`. Create a new project
using the `ng new` command:

----
ng new ng2-demo
----

[NOTE]
====
Angular CLI requires Node 4 or greater. I used node v4.2.6 and npm 3.9.3 for this tutorial.
====

This will create a `ng-demo` project and run `npm install` in it. It takes about a minute to complete,
but will vary based on your internet connection speed.

----
$ ng new ng2-demo
installing ng2
  create .clang-format
  create .editorconfig
  create src/app/ng2-demo.component.css
  create src/app/ng2-demo.component.html
  create src/app/ng2-demo.component.spec.ts
  create src/app/ng2-demo.component.ts
  create src/app/environment.ts
  create src/app/index.ts
  create src/app/shared/index.ts
  create src/favicon.ico
  create src/index.html
  create src/main.ts
  create src/system-config.ts
  create src/tsconfig.json
  create src/typings.d.ts
  create angular-cli-build.js
  create angular-cli.json
  create config/environment.dev.ts
  create config/environment.js
  create config/environment.prod.ts
  create config/karma-test-shim.js
  create config/karma.conf.js
  create config/protractor.conf.js
  create e2e/app.e2e.ts
  create e2e/app.po.ts
  create e2e/tsconfig.json
  create e2e/typings.d.ts
  create .gitignore
  create package.json
  create public/.npmignore
  create tslint.json
  create typings.json
Successfully initialized git.
⠼ Installing packages for tooling via npm
├── es6-shim (ambient)
├── angular-protractor (ambient dev)
├── jasmine (ambient dev)
└── selenium-webdriver (ambient dev)

Installed packages for tooling via npm.
58s $
----

[TIP]
====
If you have the `tee` command installed, you can view this project's files using `tree -I "dist|node_modules|typings|tmp" .`.
====

== Run the application

The project is configured with a simple web server for development. To start it, run:

----
ng serve
----

You should see a screen like the one below at http://localhost:4200.

[[default-homepage]]
.Default homepage
image::src/assets/images/default-homepage.png[Default Homepage, 800, scaledwidth="100%"]

You can make sure your new project's tests pass, run `ng test`:

----
$ ng test
Built project successfully. Stored in "dist/".

Build successful - 1131ms.

Slowest Trees                                 | Total
----------------------------------------------+---------------------
BroccoliTypeScriptCompiler                    | 685ms
vendor                                        | 255ms
HandlebarReplace                              | 141ms

Slowest Trees (cumulative)                    | Total (avg)
----------------------------------------------+---------------------
BroccoliTypeScriptCompiler (1)                | 685ms
vendor (1)                                    | 255ms
HandlebarReplace (1)                          | 141ms

12 06 2016 12:41:54.035:WARN [karma]: No captured browser, open http://localhost:9876/
12 06 2016 12:41:54.048:INFO [karma]: Karma v0.13.22 server started at http://localhost:9876/
12 06 2016 12:41:54.052:INFO [launcher]: Starting browser Chrome
12 06 2016 12:41:55.127:INFO [Chrome 51.0.2704 (Mac OS X 10.11.5)]: Connected on socket /#keU2x2a5Zf-zSJEDAAAA with id 28345914
Chrome 51.0.2704 (Mac OS X 10.11.5): Executed 4 of 4 SUCCESS (0.206 secs / 0.201 secs)
----

== Add a search feature

To add a search feature, open the project in an IDE or your favorite text editor. For IntelliJ IDEA, use
File > New Project > Static Web and point to the `ng2-demo` directory.

=== The Basics

In a terminal window, cd into your project's directory and run the following command. This will create a search
component and map its route.

[source]
----
$ ng g route search
installing route
installing component
  create src/app/+search/search.component.css
  create src/app/+search/search.component.html
  create src/app/+search/search.component.spec.ts
  create src/app/+search/search.component.ts
  create src/app/+search/index.ts
  create src/app/+search/shared/index.ts
----

To navigate to this component, add a link in `src/app/ng2-demo.component.html`.

[source,xml]
----
<a [routerLink]="['/search']">Search</a>
----

Open `src/app/+search/search.component.html` and replace its default HTML with the following:

[source,xml]
.src/client/app/+search/search.component.html
----
<h2>Search</h2>
<form>
  <input type="search" [(ngModel)]="query" (keyup.enter)="search()">
  <button type="button" (click)="search()">Search</button>
</form>
<pre>{{searchResults | json}}</pre>
----

In `src/app/+search/search.component.ts`, add imports for the core, form and router directives. Then
configure them as part of the component.

[source,js]
.src/app/+search/search.component.ts
----
import { CORE_DIRECTIVES, FORM_DIRECTIVES } from '@angular/common';
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component({
  moduleId: module.id,
  selector: 'app-search',
  templateUrl: 'search.component.html',
  styleUrls: ['search.component.css'],
  directives: [FORM_DIRECTIVES, CORE_DIRECTIVES, ROUTER_DIRECTIVES]
})
----

[NOTE]
====
The file `src/app/+search/index.ts` exports `SearchComponent` and `Ng2DemoAppComponent`
(in `src/app/ng2-demo.component.ts`) imports it and maps its route. This happened when you ran Angular CLI's
`g route` command.
====

If you still have `ng serve` running, your browser should refresh automatically. If not, navigate to http://localhost:4200,
click on the "Search" link and you should see the search form.

[[search-component]]
.Search component
image::src/assets/images/search-without-css.png[Search component, 800, scaledwidth="100%"]

If you want to add CSS for this components, open `src/app/+search/search.component.css` and add some CSS. For example:

[source,css]
.src/app/+search/search.component.css
----
:host {
  display: block;
  padding: 0 20px;
}
----

[NOTE]
====
If you add CSS, you might notice there's no auto reload in your browser. This is a https://github.com/angular/angularcli/issues/815[known issue].
====

This section has shown you how to generate a new component to a basic Angular 2 application with Angular CLI.
The next section shows you how to create a use a JSON file and `localStorage` to create a fake API.

=== The Backend

To get search results, create a `SearchService` that makes HTTP requests to a JSON file. Start
by generating a new service.

----
ng g service search
----

Move the generated `search.service.ts` and its test to `app/shared/search`. You will likely need to create this directory.

Then, create `src/app/shared/search/data/people.json` to hold your data.

[source,json]
.src/app/shared/search/data/people.json
----
[
  {
    "id": 1,
    "name": "Peyton Manning",
    "phone": "(303) 567-8910",
    "address": {
      "street": "1234 Main Street",
      "city": "Greenwood Village",
      "state": "CO",
      "zip": "80111"
    }
  },
  {
    "id": 2,
    "name": "Demaryius Thomas",
    "phone": "(720) 213-9876",
    "address": {
      "street": "5555 Marion Street",
      "city": "Denver",
      "state": "CO",
      "zip": "80202"
    }
  },
  {
    "id": 3,
    "name": "Von Miller",
    "phone": "(917) 323-2333",
    "address": {
      "street": "14 Mountain Way",
      "city": "Vail",
      "state": "CO",
      "zip": "81657"
    }
  }
]
----

Modify `src/app/shared/search/search.service.ts` and provide `Http` as a dependency in its constructor.
In this same file, define the `Address` and `Person` classes that JSON will be marshalled to.

[source,javascript]
.src/app/shared/search/search.service.ts
----
import { Injectable } from '@angular/core';
import { Http, Response } from '@angular/http';

@Injectable()
export class SearchService {
  constructor(private http:Http) {}

  getAll() {
    return this.http.get('app/shared/search/data/people.json').map((res:Response) => res.json());
  }
}

export class Address {
  street:string;
  city:string;
  state:string;
  zip:string;

  constructor(obj?:any) {
    this.street = obj && obj.street || null;
    this.city = obj && obj.city || null;
    this.state = obj && obj.state || null;
    this.zip = obj && obj.zip || null;
  }
}

export class Person {
  id:number;
  name:string;
  phone:string;
  address:Address;

  constructor(obj?:any) {
    this.id = obj && Number(obj.id) || null;
    this.name = obj && obj.name || null;
    this.phone = obj && obj.phone || null;
    this.address = obj && obj.address || null;
  }
}
----

In `search.component.ts`, add imports for these classes.

[source,javascript]
.src/app/+search/search.component.ts
----
import { Person, SearchService } from '../shared/index';
----

You can now add `query` and `searchResults` variables. While you're there, modify the constructor to inject the `SearchService`.

[source,javascript]
.src/client/app/+search/search.component.ts
----
export class SearchComponent implements OnInit {
  query:string;
  searchResults: Array<Person>;

  constructor(public searchService: SearchService) {}
----

Then implement the `search()` method to call the service's `getAll()` method.

[source,javascript]
.src/app/+search/search.component.ts
----
search(): void {
  this.searchService.getAll().subscribe(
    data => {this.searchResults = data;},
    error => console.log(error)
  );
}
----

At this point, you'll likely see the following message in your browser's console.

----
ORIGINAL EXCEPTION: No provider for SearchService!
----

This happens because the app hasn't provided this service to components. To fix this, modify
`src/app/shared/search/index.ts` to export the `SearchService`.

[source,javascript]
.src/app/shared/search/index.ts
----
export * from './search/search.service';
----

To fix the "No provider" error from above, update `ng2-demo.component.ts` to import the `SearchService`
and add the service to the list of providers.

[source,javascript]
.src/app/ng2-demo.component.ts
----
import { SearchService } from './shared/index';

@Component({
  ...
  providers: [HTTP_PROVIDERS, ROUTER_PROVIDERS],
  viewProviders: [SearchService]
})
----

Now clicking the search button should work. To make the results look better,
remove the `<pre>` tag and replace it with a `<table>`.

[source,xml]
.src/app/+search/search.component.html
----
<table *ngIf="searchResults">
  <thead>
  <tr>
    <th>Name</th>
    <th>Phone</th>
    <th>Address</th>
  </tr>
  </thead>
  <tbody>
  <tr *ngFor="let person of searchResults; let i=index">
    <td>{{person.name}}</td>
    <td>{{person.phone}}</td>
    <td>{{person.address.street}}<br/>
      {{person.address.city}}, {{person.address.state}} {{person.address.zip}}
    </td>
  </tr>
  </tbody>
</table>
----

Then add some additional CSS to improve its table layout.

[source,css]
.src/app/+search/search.component.css
----
table {
  margin-top: 10px;
  border-collapse: collapse;
}

th {
  text-align: left;
  border-bottom: 2px solid #ddd;
  padding: 8px;
}

td {
  border-top: 1px solid #ddd;
  padding: 8px;
}
----

Now the search results look better.

[[search-results]]
.Search results
image::src/assets/images/search-results.png[Search Results, 800, scaledwidth="100%"]

But wait, we still don't have search functionality! To add a search feature, add a `search()` method to `SearchService`.

[source,javascript]
.src/app/shared/search/search.service.ts
----
search(q:string) {
  if (!q || q === '*') {
    q = '';
  } else {
    q = q.toLowerCase();
  }
  return this.getAll().map(data => {
    let results:any = [];
    data.map(item => {
      if (JSON.stringify(item).toLowerCase().includes(q)) {
        results.push(item);
      }
    });
    return results;
  });
}
----

Then refactor `SearchComponent` to call this method with its `query` variable.

[source,javascript]
.src/app/+search/search.component.ts
----
search(): void {
  this.searchService.search(this.query).subscribe(
    data => {this.searchResults = data;},
    error => console.log(error)
  );
}
----

Now search results will be filtered by the query value you type in.

This section showed you how to fetch and display search results. The next section builds on this and shows how to edit and save a record.

== Add an edit feature

Modify `search.component.html` to add a link for editing a person.

[source,html]
.src/app/+search/search.component.html
----
<td><a [routerLink]="['/edit', person.id]">{{person.name}}</a></td>
----

Run the following command to generate an `EditComponent` and an associated route.

[source]
----
$ ng g route edit
installing route
installing component
  create src/app/+edit/edit.component.css
  create src/app/+edit/edit.component.html
  create src/app/+edit/edit.component.spec.ts
  create src/app/+edit/edit.component.ts
  create src/app/+edit/index.ts
  create src/app/+edit/shared/index.ts
----

Update `src/app/+edit/edit.component.html` to display an editable form. You might notice I've added `id` attributes to most elements. This is to
make things easier when writing integration tests with Protractor.

[source,html]
.src/app/+edit/edit.component.html
----
<div *ngIf="person">
  <h3>{{editName}}</h3>
  <div>
    <label>Id:</label>
    {{person.id}}
  </div>
  <div>
    <label>Name:</label>
    <input [(ngModel)]="editName" id="name" placeholder="name"/>
  </div>
  <div>
    <label>Phone:</label>
    <input [(ngModel)]="editPhone" id="phone" placeholder="Phone"/>
  </div>
  <fieldset>
    <legend>Address:</legend>
    <address>
      <input [(ngModel)]="editAddress.street" id="street"><br/>
      <input [(ngModel)]="editAddress.city" id="city">,
      <input [(ngModel)]="editAddress.state" id="state" size="2">
      <input [(ngModel)]="editAddress.zip" id="zip" size="5">
    </address>
  </fieldset>
  <button (click)="save()" id="save">Save</button>
  <button (click)="cancel()" id="cancel">Cancel</button>
</div>
----

Modify `EditComponent` to import model and service classes and to use the `SearchService` to get data.

[source,javascript]
.src/app/+edit/edit.component.ts
----
import { Component, OnInit } from '@angular/core';
import { Person, Address, SearchService } from '../shared/index';
import { RouteSegment, Router } from '@angular/router';

@Component({
  selector: 'app-edit',
  moduleId: module.id,
  templateUrl: 'edit.component.html',
  styleUrls: ['edit.component.css']
})
export class EditComponent implements OnInit {

  person: Person;
  editName: string;
  editPhone: string;
  editAddress: Address;

  constructor(
    private _service: SearchService,
    private _router: Router,
    private _routeSegment: RouteSegment
  ) { }

  ngOnInit() {
    let id = +this._routeSegment.getParam('id');
    this._service.get(id).subscribe(person => {
      if (person) {
        this.editName = person.name;
        this.editPhone = person.phone;
        this.editAddress = person.address;
        this.person = person;
      } else {
        this.gotoList();
      }
    });
  }

  cancel() {
    this._router.navigate(['/search']);
  }

  save() {
    this.person.name = this.editName;
    this.person.phone = this.editPhone;
    this.person.address = this.editAddress;
    this._service.save(this.person);
    this.gotoList();
  }

  gotoList() {
    if (this.person) {
      this._router.navigate(['/search', {term: this.person.name} ]);
    } else {
      this._router.navigate(['/search']);
    }
  }
}
----

Modify `SearchService` to contain functions for finding a person by their id, and saving them. While you're in there, modify the `search()` method to
be aware of updated objects in `localStorage`.

[source,javascript]
.src/app/shared/search/search.service.ts
----
search(q:string) {
  if (!q || q === '*') {
    q = '';
  } else {
    q = q.toLowerCase();
  }
  return this.getAll().map(data => {
    let results:any = [];
    data.map(item => {
      // check for item in localStorage
      if (localStorage['person' + item.id]) {
        item = JSON.parse(localStorage['person' + item.id]);
      }
      if (JSON.stringify(item).toLowerCase().includes(q)) {
        results.push(item);
      }
    });
    return results;
  });
}

get(id: number) {
  return this.getAll().map(all => {
    if (localStorage['person' + id]) {
      return JSON.parse(localStorage['person' + id]);
    }
    return all.find(e => e.id === id);
  });
}

save(person: Person) {
  localStorage['person' + person.id] = JSON.stringify(person);
}
----

You can add CSS to `src/app/+edit/edit.component.css` if you want to make the form look a bit better.

[source,css]
.src/app/+edit/edit.component.css
----
:host {
  display: block;
  padding: 0 20px;
}

button {
  margin-top: 10px;
}
----

At this point, you should be able to search for a person and update their information.

[[edit-form]]
.Edit component
image::src/assets/images/edit-form.png[Edit form, 800, scaledwidth="100%"]

The &lt;form> in `src/app/+edit/edit.component.html` calls a `save()` function to update a person's data. You already implemented this above.
The function calls a `gotoList()` function that appends the person's name to the URL when sending the user back to the search screen.

[source,javascript]
.src/app/+edit/edit.component.ts
----
gotoList() {
  if (this.person) {
    this._router.navigate(['/search', {term: this.person.name} ]);
  } else {
    this._router.navigate(['/search']);
  }
}
----

Since the `SearchComponent` doesn't execute a search automatically when you execute this URL, add the following logic to do so in its constructor.

[source,javascript]
.src/app/+search/search.component.ts
----
constructor(public searchService: SearchService, routeSegment: RouteSegment) {
  if (routeSegment.getParam('term')) {
    this.query = decodeURIComponent(routeSegment.getParam('term'));
    this.search();
  }
}
----

You'll need to import `RouteSegment` in order for everything to compile.

[source,javascript]
.src/app/+search/search.component.ts
----
import { ROUTER_DIRECTIVES, RouteSegment } from '@angular/router';
----

After making all these changes, you should be able to search/edit/update a person's information. If it works - nice job!

=== Unit test the SearchService

Modify `src/app/shared/search/search.service.spec.ts` and setup the test's infrastructure using https://angular.io/docs/js/latest/api/http/testing/MockBackend-class.html[MockBackend]
and https://angular.io/docs/js/latest/api/http/BaseRequestOptions-class.html[BaseRequestOptions].

[source,javascript]
.src/app/shared/search/search.service.spec.ts
----
import {
  beforeEachProviders,
  it,
  describe,
  expect,
  inject,
  fakeAsync,
  tick
} from '@angular/core/testing';
import { MockBackend } from '@angular/http/testing';
import { provide } from '@angular/core';
import { Http, ConnectionBackend, BaseRequestOptions, Response, ResponseOptions } from '@angular/http';
import { SearchService } from './search.service';

export function main() {
  describe('Search Service', () => {
    beforeEachProviders(() => {
      return [BaseRequestOptions, MockBackend, SearchService,
        provide(Http, {
          useFactory: (backend:ConnectionBackend, defaultOptions:BaseRequestOptions) => {
            return new Http(backend, defaultOptions);
          }, deps: [MockBackend, BaseRequestOptions]
        }),
      ];
    });
  });
}
----

If you run `ng test`, all tests will pass, but you don't see "Search Service" as a listed test. You can fix this by adding the first test of `getAll()`. This test shows how
`MockBackend` can be used to mock results and set the response.

TIP: When you are testing code that returns either a Promise or an RxJS Observable, you can use the `fakeAsync` helper to test that code as if it were synchronous.
Promises are be fulfilled and Observables are notified immediately after you call `tick()`.

The test below should be on the same level as `beforeEachProviders`.

[source,javascript]
.src/app/shared/search/search.service.spec.ts
----
it('should retrieve all search results',
  inject([SearchService, MockBackend], fakeAsync((searchService:SearchService, mockBackend:MockBackend) => {
    var res:Response;
    mockBackend.connections.subscribe(c => {
      expect(c.request.url).toBe('app/shared/search/data/people.json');
      let response = new ResponseOptions({body: '[{"name": "John Elway"}, {"name": "Gary Kubiak"}]'});
      c.mockRespond(new Response(response));
    });
    searchService.getAll().subscribe((response) => {
      res = response;
    });
    tick();
    expect(res[0].name).toBe('John Elway');
  }))
);
----

Running `ng test` should result in "12 tests completed". Add a couple more tests for filtering by search term and fetching by id.

[source,javascript]
.src/app/shared/search/search.service.spec.ts
----
it('should filter by search term',
  inject([SearchService, MockBackend], fakeAsync((searchService:SearchService, mockBackend:MockBackend) => {
    var res;
    mockBackend.connections.subscribe(c => {
      expect(c.request.url).toBe('app/shared/search/data/people.json');
      let response = new ResponseOptions({body: '[{"name": "John Elway"}, {"name": "Gary Kubiak"}]'});
      c.mockRespond(new Response(response));
    });
    searchService.search('john').subscribe((response) => {
      res = response;
    });
    tick();
    expect(res[0].name).toBe('John Elway');
  }))
);

it('should fetch by id',
  inject([SearchService, MockBackend], fakeAsync((searchService:SearchService, mockBackend:MockBackend) => {
    var res;
    mockBackend.connections.subscribe(c => {
      expect(c.request.url).toBe('app/shared/search/data/people.json');
      let response = new ResponseOptions({body: '[{"id": 1, "name": "John Elway"}, {"id": 2, "name": "Gary Kubiak"}]'});
      c.mockRespond(new Response(response));
    });
    searchService.search('2').subscribe((response) => {
      res = response;
    });
    tick();
    expect(res[0].name).toBe('Gary Kubiak');
  }))
);
----

Notice that tests continually run as you add them when using `ng test`. You can run tests once by using `ng test --watch=false`.

== Unit test the SearchComponent

To unit test the `SearchComponent`, create a `MockSearchProvider` that has http://angular-tips.com/blog/2014/03/introduction-to-unit-test-spies/[spies].
These allow you to _spy_ on functions to check if they were called.

Create `src/app/shared/search/mocks/search.service.ts` and populate it with spies for each method, as well as methods to set the response and subscribe to results.

[source,javascript]
.src/app/shared/search/mocks/search.service.ts
----
import { provide } from '@angular/core';
import { SpyObject } from './helper';

import { SearchService } from '../search.service';
import Spy = jasmine.Spy;

export class MockSearchService extends SpyObject {
  getAllSpy:Spy;
  getByIdSpy:Spy;
  searchSpy:Spy;
  saveSpy:Spy;
  fakeResponse:any;

  constructor() {
    super(SearchService);

    this.fakeResponse = null;
    this.getAllSpy = this.spy('getAll').andReturn(this);
    this.getByIdSpy = this.spy('get').andReturn(this);
    this.searchSpy = this.spy('search').andReturn(this);
    this.saveSpy = this.spy('save').andReturn(this);
  }

  subscribe(callback:any) {
    callback(this.fakeResponse);
  }

  setResponse(json:any):void {
    this.fakeResponse = json;
  }

  getProviders():Array<any> {
    return [provide(SearchService, {useValue: this})];
  }
}
----

In this same directory, create a `helper.ts` class to implement the `SpyObject` that `MockSearchService` extends.

[source,javascript]
.src/app/shared/search/mocks/helper.ts
----
import {StringMapWrapper} from '@angular/core/src/facade/collection';

export interface GuinessCompatibleSpy extends jasmine.Spy {
  /** By chaining the spy with and.returnValue, all calls to the function will return a specific
   * value. */
  andReturn(val: any): void;
  /** By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied
   * function. */
  andCallFake(fn: Function): GuinessCompatibleSpy;
  /** removes all recorded calls */
  reset();
}

export class SpyObject {
  static stub(object = null, config = null, overrides = null) {
    if (!(object instanceof SpyObject)) {
      overrides = config;
      config = object;
      object = new SpyObject();
    }

    var m = StringMapWrapper.merge(config, overrides);
    StringMapWrapper.forEach(m, (value, key) => { object.spy(key).andReturn(value); });
    return object;
  }

  constructor(type = null) {
    if (type) {
      for (var prop in type.prototype) {
        var m = null;
        try {
          m = type.prototype[prop];
        } catch (e) {
          // As we are creating spys for abstract classes,
          // these classes might have getters that throw when they are accessed.
          // As we are only auto creating spys for methods, this
          // should not matter.
        }
        if (typeof m === 'function') {
          this.spy(prop);
        }
      }
    }
  }

  spy(name) {
    if (!this[name]) {
      this[name] = this._createGuinnessCompatibleSpy(name);
    }
    return this[name];
  }

  prop(name, value) { this[name] = value; }

  /** @internal */
  _createGuinnessCompatibleSpy(name): GuinessCompatibleSpy {
    var newSpy: GuinessCompatibleSpy = <any>jasmine.createSpy(name);
    newSpy.andCallFake = <any>newSpy.and.callFake;
    newSpy.andReturn = <any>newSpy.and.returnValue;
    newSpy.reset = <any>newSpy.calls.reset;
    // revisit return null here (previously needed for rtts_assert).
    newSpy.and.returnValue(null);
    return newSpy;
  }
}
----

Alongside, create `routes.ts` to mock Angular's `RouteSegment`.

[source,javascript]
.src/app/shared/search/mocks/routes.ts
----
import { RouteSegment } from '@angular/router';

export class MockRouteSegment implements RouteSegment {
  urlSegments:any;
  parameters:any;
  outlet:string;
  _type:any;
  _componentFactory:any;
  type:any;
  stringifiedUrlSegments:string;

  constructor(parameters?:{ [key:string]:any; }) {
    this.parameters = parameters;
  }

  getParam(param:string) {
    return this.parameters[param];
  }
}
----

With mocks in place, you can update the test for `SearchComponent` that uses these as providers.

[source,javascript]
.src/app/+search/search.component.spec.ts
----
import { provide } from '@angular/core';
import { TestComponentBuilder } from '@angular/compiler/testing';
import {
  it,
  describe,
  expect,
  inject,
  beforeEachProviders,
} from '@angular/core/testing';

import { RouteSegment } from '@angular/router';
import { MockRouteSegment } from '../shared/search/mocks/routes';
import { MockSearchService } from '../shared/search/mocks/search.service';

import { SearchComponent } from './search.component';

export function main() {
  describe('Search component', () => {
    var mockSearchService:MockSearchService;

    beforeEachProviders(() => {
      mockSearchService = new MockSearchService();

      return [
        mockSearchService.getProviders(),
        provide(RouteSegment, { useValue: new MockRouteSegment({ 'term': 'peyton' }) })
      ];
    });
  });
}
----

Add two tests, one to verify a search term is used when it's set on the component and a second to verify search is called when a term is passed in as a route
parameter.

[source,javascript]
.src/app/+search/search.component.spec.ts
----
it('should search when a term is set and search() is called', inject([TestComponentBuilder], (tcb:TestComponentBuilder) => {
  return tcb.createAsync(SearchComponent).then((fixture) => {
    let searchComponent = fixture.debugElement.componentInstance;
    searchComponent.query = 'M';
    searchComponent.search();
    expect(mockSearchService.searchSpy).toHaveBeenCalledWith('M');
  });
}));

it('should search automatically when a term is on the URL', inject([TestComponentBuilder], (tcb:TestComponentBuilder) => {
  return tcb.createAsync(SearchComponent).then((fixture) => {
    fixture.detectChanges();
    expect(mockSearchService.searchSpy).toHaveBeenCalledWith('peyton');
  });
}));
----

Update the test for `EditComponent` as well, verifying fetching a single record works. Notice how you can access the component directly with
`fixture.debugElement.componentInstance`, or its rendered version with `fixture.debugElement.nativeElement`.

[source,javascript]
.src/app/+edit/edit.component.spec.ts
----
import { provide } from '@angular/core';
import { TestComponentBuilder } from '@angular/compiler/testing';
import {
  it,
  describe,
  expect,
  inject,
  beforeEachProviders,
} from '@angular/core/testing';

import { RouteSegment } from '@angular/router';
import { ROUTER_FAKE_PROVIDERS } from '@angular/router/testing';
import { MockRouteSegment } from '../shared/search/mocks/routes';
import { MockSearchService } from '../shared/search/mocks/search.service';

import { EditComponent } from './edit.component';

describe('Edit component', () => {
  var mockSearchService:MockSearchService;

  beforeEachProviders(() => {
    mockSearchService = new MockSearchService();

    return [
      mockSearchService.getProviders(),
      ROUTER_FAKE_PROVIDERS,
      provide(RouteSegment, { useValue: new MockRouteSegment({ 'id': '1' }) })
    ];
  });

  it('should fetch a single record', inject([TestComponentBuilder], (tcb:TestComponentBuilder) => {
    return tcb.createAsync(EditComponent).then((fixture) => {
      let person = {name: 'Emmanuel Sanders', address: {city: 'Denver'}};
      mockSearchService.setResponse(person);

      fixture.detectChanges();
      // verify service was called
      expect(mockSearchService.getByIdSpy).toHaveBeenCalledWith(1);

      // verify data was set on component when initialized
      let editComponent = fixture.debugElement.componentInstance;
      expect(editComponent.editAddress.city).toBe('Denver');

      // verify HTML renders as expected
      var compiled = fixture.debugElement.nativeElement;
      expect(compiled.querySelector('h3')).toHaveText('Emmanuel Sanders');
    });
  }));
});
----

You should see "Executed 5 of 5 [green]SUCCESS[/green] (0.238 secs / 0.259 secs)" in the shell window that's running `ng test`. If you don't, try cancelling the command and restarting.

== Integration test the search UI

To test if the application works end-to-end, you can write tests with http://angular.github.io/protractor[Protractor]. These are also known as integration tests,
since they test the _integration_ between all layers of your application.

To verify end-to-end tests work in the project before you begin, run the following commands in three different console windows.

----
ng serve
ng e2e
----

All tests should pass.

----
⌁ [mraible:~/ng2-demo] tutorial(+0/-0) 35s 130 ± ng e2e

> ng2-demo@0.0.0 pree2e /Users/mraible/ng2-demo
> webdriver-manager update

selenium standalone is up to date.
chromedriver is up to date.

> ng2-demo@0.0.0 e2e /Users/mraible/ng2-demo
> protractor "config/protractor.conf.js"

[21:45:37] I/direct - Using ChromeDriver directly...
[21:45:37] I/launcher - Running 1 instances of WebDriver
Spec started

  ng2-demo App
    ✓ should display message saying app works

Executed 1 of 1 spec SUCCESS in 2 secs.
[21:45:40] I/launcher - 0 instance(s) of WebDriver still running
[21:45:40] I/launcher - chrome #01 passed

All end-to-end tests pass.
⌁ [mraible:~/ng2-demo] tutorial(+0/-0) 5s ±
----

=== Testing the search feature

Create end-to-end tests in `e2e/search.e2e.ts` to verify the search feature works. Populate it with the following code:

[source,javascript]
.e2e/search.e2e.ts
----
describe('Search', () => {

  beforeEach(() => {
    browser.get('/search');
    element(by.linkText('Search')).click();
  });

  it('should have an input and search button', () => {
    expect(element(by.css('ng2-demo-app app-search form input')).isPresent()).toEqual(true);
    expect(element(by.css('ng2-demo-app app-search form button')).isPresent()).toEqual(true);
  });

  it('should allow searching', () => {
    let searchButton = element(by.css('button'));
    let searchBox = element(by.css('input'));
    searchBox.sendKeys('M');
    searchButton.click().then(() => {
      // doesn't work as expected - results in 0
      //expect(element.all(by.repeater('person of searchResults')).count()).toEqual(3);
      var list = element.all(by.css('app-search table tbody tr'));
      expect(list.count()).toBe(3);
    });
  });
});

----

=== Testing the edit feature

Create a `e2e/edit.e2e.ts` test to verify the `EditComponent` renders a person's information and that you can update their information.

[source,javascript]
.e2e/edit.e2e.ts
----
describe('Edit', () => {

  beforeEach(() => {
    browser.get('/edit/1');
  });

  let name = element(by.id('name'));
  let street = element(by.id('street'));
  let city = element(by.id('city'));

  it('should allow viewing a person', () => {
    expect(element(by.css('h3')).getText()).toEqual('Peyton Manning');
    expect(name.getAttribute('value')).toEqual('Peyton Manning');
    expect(street.getAttribute('value')).toEqual('1234 Main Street');
    expect(city.getAttribute('value')).toEqual('Greenwood Village');
  });

  it('should allow updating a name', function () {
    let save = element(by.id('save'));
    // send individual characters since sendKeys passes partial values sometimes
    // https://github.com/angular/protractor/issues/698
    ' Won!'.split('').forEach((c) => name.sendKeys(c));
    save.click();
    // verify one element matched this change
    var list = element.all(by.css('app-search table tbody tr'));
    expect(list.count()).toBe(1);
  });
});
----

Run `ng e2e` to verify all your end-to-end tests pass. You should see a success message similar to the one below in your terminal window.

[[protractor-success]]
.Protractor success
image::src/assets/images/protractor-success.png[Protractor success, 800, scaledwidth="100%"]

If you made it this far and have all 13 specs passing - congratulations!
You're well on your way to writing quality code with Angular 2 and verifying it works.

[NOTE]
----
Angular CLI doesn't currently support generating test coverage reports, but you can https://github.com/angular/angular-cli/issues/883[watch
this issue] and you'll be notified when it does.
----

== Source code

A completed project with this code in it is available on GitHub at https://github.com/mraible/ng2-demo.

== Summary

I hope you've enjoyed this quick-and-easy tutorial on how to get started with Angular 2 and Angular CLI. Angular CLI
takes much of the pain out of setting up an Angular 2 project and using Typescript. I expect great things from Angular CLI,
because the Angular 2 setup process needs it. ;)
